안녕하세요! 저희 팀 프로젝트에서 맛집 검색 및 저장 기능 파트를 맡은 OOO입니다.

제가 구현한 부분은 사용자가 카카오 지도 API를 활용해 맛집을 검색하고, 마음에 드는 장소를 우리 서비스에 저장하여 개인화된 맛집 목록을 지도와 함께 관리하는 기능입니다.

📂 전체 구조
먼저 제가 작업한 부분의 전체적인 구조입니다. 역할과 책임에 따라 명확하게 폴더와 파일을 분리하여 유지보수가 용이하도록 설계했습니다.

Backend (Spring Boot)

Controller: 사용자의 요청을 받아 화면을 보여주는 ViewController와, 데이터만 처리하는 RestController(API)로 역할을 분리했습니다.

Service: 실제 비즈니스 로직을 처리합니다. 카카오 API 연동이나 DB 저장 로직이 여기에 있습니다.

Repository & Domain: JPA와 QueryDSL을 사용해 DB 데이터를 효율적으로 처리하도록 구현했습니다.

Frontend (Thymeleaf)

templates/lunchmatch: 맛집 기능 관련 화면(search, list, read, modify)들을 모아두었습니다.

templates/layout: 모든 페이지에 공통으로 적용되는 헤더/푸터(layout.html)를 분리해 재사용성을 높였습니다.

static/css: 여러 페이지에 흩어져 있던 스타일을 lunchmatch.css 하나로 통합하여 디자인의 일관성을 확보했습니다.

이 구조 덕분에 백엔드는 데이터 처리에, 프론트엔드는 화면 표시에만 집중할 수 있었습니다.

🗺️ 핵심 기능 1: 카카오 API를 이용한 맛집 검색 (search.html)
가장 핵심적인 기능인 맛집 검색 및 저장 흐름입니다.

사용자가 search.html에서 '부산 서면 맛집'을 검색합니다.

JavaScript의 performSearch() 함수가 이 요청을 우리 서버의 특정 주소(searchKakaoPlaces)로 보냅니다.

서버는 카카오 API에 다시 검색을 요청하고, 받아온 결과(JSON)를 그대로 프론트로 전달합니다.

프론트에서는 displayPlaces() 함수가 이 데이터를 받아 왼쪽에는 목록을, 오른쪽에는 지도 마커를 동적으로 생성합니다.
--------------------------------------------------------------------------------------------
// search.html 의 savePlace() 함수
async function savePlace(event, index) {
    // ...
    const place = originalPlaces[index];
    const placeData = { // 저장할 맛집 데이터를 JSON 객체로 만듭니다.
        name: place.place_name,
        address: place.road_address_name || place.address_name,
        // ... 위도, 경도 등
    };

    // fetch API를 사용해 우리 서버의 API(/api/lunchmatches)에 POST 방식으로 데이터를 전송합니다.
    const response = await fetch('/api/lunchmatches', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(placeData),
    });
    // ...
}
--------------------------------------------------------------------------------------------------
이처럼 프론트엔드에서 비동기(AJAX) 통신으로 필요한 데이터만 서버와 주고받아, 페이지 새로고침 없이 부드러운 사용자 경험을 제공합니다.

LunchMatchController의 저장 API 코드
서버에서는 @RestController가 이 요청을 받아 처리합니다.

-----------------------------------------------------------------------------------------------------
// LunchMatchController.java
@RestController
@RequestMapping("/api/lunchmatches")
public class LunchMatchController {

    private final LunchMatchService lunchMatchService;

    @PostMapping // POST 요청을 처리하는 API
    public ResponseEntity<?> register(@Valid @RequestBody LunchMatchDTO lunchMatchDTO) {
        // @RequestBody가 프론트에서 보낸 JSON 데이터를 LunchMatchDTO 객체로 변환해줍니다.
        Long rno = lunchMatchService.register(lunchMatchDTO); // 서비스 레이어에 데이터 저장을 위임합니다.

        // ... 중복 체크 및 결과 반환
    }
}
-------------------------------------------------------------------------------------------------------

이 과정을 통해 카카오 API의 외부 데이터가 성공적으로 우리 서비스의 DB에 저장됩니다.



핵심 기능 2: 저장된 맛집 조회 및 관리 (list.html)
다음은 사용자가 저장한 맛집들을 확인하는 list.html 페이지입니다.

이 페이지는 로드될 때 JavaScript의 fetchRestaurantsAndDisplay() 함수를 통해 우리 DB에 저장된 맛집 데이터를 서버에 요청합니다.

▼ LunchMatchViewController의 데이터 조회 API 코드
map.html과 달리 이 페이지는 우리 내부 데이터를 다루므로, 더 복잡한 검색과 정렬이 가능합니다.
--------------------------------------------------------------------------------------------------------------
// LunchMatchViewController.java
@GetMapping("/api/list")
@ResponseBody // HTML 페이지가 아닌 JSON 데이터를 직접 반환합니다.
public List<LunchMatchDTO> getLunchMatchesJson(
        @RequestParam(value = "keyword", ...) String keyword,
        @RequestParam(value = "orderBy", ...) String orderBy) {

    // 서비스의 searchAndSort 메서드를 호출해 조건에 맞는 데이터를 가져옵니다.
    return lunchMatchService.searchAndSort(keyword, category, minRating, orderBy);
}


------------------------------------------------------------------------------------------------------------------


LunchMatchRepositoryCustomImpl의 동적 쿼리 (QueryDSL)
특히, 이름/주소 검색, 카테고리 필터링, 평점순/이름순 등 다양한 조건의 검색 및 정렬을 구현하기 위해 QueryDSL을 사용했습니다.

----------------------------------------------------------------------------------

// LunchMatchRepositoryCustomImpl.java (QueryDSL 구현체)
public class LunchMatchRepositoryCustomImpl implements LunchMatchRepositoryCustom {
    // ...
    @Override
    public List<LunchMatch> search(List<String> keywords, String category, String orderBy) {
        QLunchMatch lunchMatch = QLunchMatch.lunchMatch;
        BooleanBuilder builder = new BooleanBuilder(); // 조건들을 동적으로 조합합니다.

        // 검색어가 있으면 이름 또는 주소에 포함되는지 확인
        if (keywords != null && !keywords.isEmpty()) {
            // ... or 조건 추가
        }
        // 카테고리가 있으면 카테고리 조건 추가
        if (StringUtils.hasText(category)) {
            builder.and(lunchMatch.category.containsIgnoreCase(category));
        }

        // 정렬 조건에 따라 동적으로 OrderSpecifier 생성
        // ...

        return queryFactory.selectFrom(lunchMatch).where(builder).orderBy(orderSpecifier).fetch();
    }
}

----------------------------------------------------------------------------------------------


QueryDSL 덕분에 복잡한 DB 쿼리를 자바 코드로 안전하고 가독성 높게 작성할 수 있었습니다. 조회된 데이터는 이전과 마찬가지로 list.html의 목록과 지도에 동적으로 뿌려집니다.


✨ 마무리
제가 구현한 파트는 외부 API(카카오)의 데이터를 우리 서비스의 내부 데이터로 전환하고, 이를 사용자에게 맞게 가공하여 다시 지도와 함께 보여주는 것이 핵심이었습니다.

Thymeleaf 레이아웃과 외부 CSS를 통해 UI의 일관성과 재사용성을 높였고, JPA와 QueryDSL을 통해 안정적인 데이터 관리가 가능하도록 구현했습니다.

추후 기회가 된다면, 현재는 클라이언트에서 모든 로직을 처리하는 부분을 서버 템플릿 렌더링과 적절히 혼합하여 초기 로딩 성능을 개선하거나, 맛집에 대한 사용자 리뷰 기능을 추가하는 방향으로 발전시키고 싶습니다.

이상으로 발표를 마치겠습니다. 감사합니다!

(끝)
