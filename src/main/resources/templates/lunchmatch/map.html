<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      layout:decorate="~{layout/layout}">
<head>
    <title>맛집 정보 검색</title>
    <th:block layout:fragment="css">
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
            main.flex-grow-1 > .container {
                max-width: 100%;
                padding: 0;
            }
            body { font-family: 'Noto Sans KR', 'Inter', sans-serif; }
            #map { width: 100%; height: 100%; }
            #menu_wrap { height: 100%; display: flex; flex-direction: column; }
            #placesList { flex-grow: 1; overflow-y: auto; }
            #pagination { flex-shrink: 0; }
            .info { padding: 5px; border-radius: 5px; }
            .info .title { font-weight: bold; font-size: 14px; }
            .highlighted { background-color: #e0f2fe !important; }
            /* ▼▼▼ 전체 지도 보기 모달 CSS 추가 ▼▼▼ */
            #fullscreen-map-modal { transition: opacity 0.3s ease-in-out; }
        </style>
    </th:block>
</head>

<div layout:fragment="content">
    <div class="bg-gray-100">
        <div class="container mx-auto p-4 flex flex-col" style="height: calc(100vh - 130px);">
            <header class="mb-4 pb-4 border-b flex-shrink-0">
                <div class="flex justify-between items-center">
                    <div>
                        <h1 class="text-3xl font-bold text-gray-800">맛집 정보 검색</h1>
                        <p class="text-gray-600">원하는 장소를 검색하여 맛집을 찾아보세요.</p>
                    </div>
                </div>
            </header>

            <div class="flex-grow grid grid-cols-1 md:grid-cols-3 gap-4 min-h-0">
                <div id="menu_wrap" class="bg-white p-4 rounded-lg shadow-md col-span-1 flex flex-col h-full overflow-hidden">
                    <div class="flex-shrink-0">
                        <form id="searchForm" onsubmit="performSearch(event, 1)" class="flex gap-2">
                            <input type="text" id="keyword" value="부산 서면" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="장소 키워드 (예: 부산 서면)"/>
                            <button type="submit" class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">검색</button>
                        </form>
                    </div>
                    <div class="filters my-4 flex flex-wrap gap-2 items-center flex-shrink-0">
                        <div class="flex-grow">
                            <label for="category" class="block text-sm font-medium text-gray-700">음식 종류:</label>
                            <select id="category" onchange="performSearch(null, 1)" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                <option value="맛집">전체 맛집</option>
                                <option value="한식">한식</option>
                                <option value="중식">중식</option>
                                <option value="일식">일식</option>
                                <option value="양식">양식</option>
                                <option value="카페">카페</option>
                                <option value="분식">분식</option>
                            </select>
                        </div>
                        <div class="flex-grow">
                            <label for="sort" class="block text-sm font-medium text-gray-700">정렬 기준:</label>
                            <select id="sort" onchange="applySortOnly()" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                <option value="accuracy">기본순</option>
                                <option value="name">이름순</option>
                                <option value="distance">거리순</option>
                            </select>
                        </div>
                    </div>
                    <hr class="mb-4 flex-shrink-0"/>
                    <ul id="placesList" class="space-y-2 flex-grow overflow-y-auto"></ul>
                    <div id="pagination" class="mt-4 flex justify-between items-center flex-shrink-0">
                        <button id="prevBtn" onclick="movePage(-1)" class="bg-gray-300 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-400 disabled:opacity-50 disabled:cursor-not-allowed">이전</button>
                        <span id="pageInfo" class="text-gray-700 text-sm"></span>
                        <button id="nextBtn" onclick="movePage(1)" class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed">다음</button>
                    </div>
                </div>
                <div class="relative col-span-1 md:col-span-2 rounded-lg shadow-md overflow-hidden">
                    <div id="map"></div>
                    <button onclick="openFullScreenMap()" class="absolute top-2 right-2 bg-white text-gray-700 font-semibold py-2 px-4 rounded-full shadow-lg z-10 hover:bg-gray-200 transition">
                        전체 지도 보기
                    </button>
                    <button onclick="displayMyLocation()" class="absolute top-14 right-2 bg-white p-2 rounded-full shadow-lg z-10 hover:bg-gray-200 text-gray-600">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
                    </button>
                    <div class="absolute top-2 left-2 z-10">
                        <select id="radiusSelect" onchange="changeSearchRadius()" class="bg-white text-gray-700 text-sm py-2 px-3 rounded-md shadow-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="500">500m</option>
                            <option value="1000">1km</option>
                            <option value="2000">2km</option>
                            <option value="5000">5km</option>
                            <option value="10000">10km</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <div id="fullscreen-map-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center opacity-0 pointer-events-none">
            <div class="relative w-11/12 h-5/6 bg-white rounded-lg shadow-2xl p-4">
                <div id="fullscreen-map" class="w-full h-full rounded-lg"></div>
                <button onclick="closeFullScreenMap()" class="absolute top-4 right-4 bg-white text-gray-800 font-bold py-2 px-4 rounded-full shadow-xl hover:bg-gray-200 transition z-10">
                    닫기
                </button>
                <button onclick="displayMyLocationOnModal()" class="absolute top-20 right-4 bg-white p-2 rounded-full shadow-lg z-10 hover:bg-gray-200 text-gray-600">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
                </button>
            </div>
        </div>
    </div>
</div>

<th:block layout:fragment="script">
    <script th:inline="javascript">
        const KAKAO_JAVASCRIPT_API_KEY = /*[[${kakaoJsApiKey}]]*/ 'YOUR_DEFAULT_KEY';
    </script>
    <script th:src="|//dapi.kakao.com/v2/maps/sdk.js?appkey=${kakaoJsApiKey}&libraries=services|"></script>
    <script>
        let map;
        let markers = [];
        let infowindow = new kakao.maps.InfoWindow({zIndex:1});
        let originalPlaces = [];
        let userLocation = null;
        let myLocationMarker = null;
        let myLocationCircle = null;
        let currentSearchRadius = 500;
        let currentActiveMarker = null;
        let currentPage = 1;
        let totalPage = 1;
        let modalMap;
        let modalMyLocationMarker = null;
        let modalMyLocationCircle = null;


        document.addEventListener("DOMContentLoaded", function() {
            const mapContainer = document.getElementById('map');
            const mapOption = { center: new kakao.maps.LatLng(35.1576, 129.0594), level: 4 };
            map = new kakao.maps.Map(mapContainer, mapOption);
            performSearch(null, 1);
        });

        async function performSearch(event, page) {
            if (event) event.preventDefault();
            currentPage = page;
            const keyword = document.getElementById('keyword').value.trim();
            const category = document.getElementById('category').value;
            if (!keyword) { alert('장소 키워드를 입력해주세요!'); return; }
            const fullKeyword = `${keyword} ${category}`;
            try {
                const response = await fetch(`/lunchmatch/searchKakaoPlaces?query=${encodeURIComponent(fullKeyword)}&page=${currentPage}`);
                if (!response.ok) throw new Error(`서버 API 호출 실패`);
                const data = await response.json();
                originalPlaces = data.documents;
                renderPagination(data.meta);
                applySortOnly();
                if (originalPlaces.length > 0) {
                    const bounds = new kakao.maps.LatLngBounds();
                    originalPlaces.forEach(place => {
                        if (typeof place.y === 'string' && typeof place.x === 'string' && !isNaN(parseFloat(place.y)) && !isNaN(parseFloat(place.x))) {
                            bounds.extend(new kakao.maps.LatLng(parseFloat(place.y), parseFloat(place.x)));
                        }
                    });
                    if (!bounds.isEmpty()) map.setBounds(bounds);
                    else map.setCenter(new kakao.maps.LatLng(35.1576, 129.0594));
                } else {
                    map.setCenter(new kakao.maps.LatLng(35.1576, 129.0594));
                }
            } catch (error) {
                console.error('검색 중 오류 발생:', error);
                alert('장소 검색 중 오류가 발생했습니다.');
                originalPlaces = [];
                displayPlaces([]);
                renderPagination({ pageable_count: 0, is_end: true });
            }
        }

        function movePage(delta) {
            const newPage = currentPage + delta;
            if (newPage > 0 && newPage <= totalPage) {
                performSearch(null, newPage);
            }
        }

        function renderPagination(meta) {
            const pageableCount = meta.pageable_count > 45 ? 45 : meta.pageable_count;
            totalPage = Math.ceil(pageableCount / 15);
            document.getElementById('pageInfo').textContent = `${currentPage} / ${totalPage}`;
            document.getElementById('prevBtn').disabled = currentPage === 1;
            document.getElementById('nextBtn').disabled = currentPage === totalPage || meta.is_end;
        }

        function applySortOnly() {
            const sort = document.getElementById('sort').value;
            let processedPlaces = [...originalPlaces];
            if (sort === 'distance') {
                getUserLocation((errorOccurred) => {
                    if (errorOccurred) {
                        document.getElementById('sort').value = 'accuracy';
                        alert("거리순 정렬을 위해 위치 정보를 가져올 수 없습니다. 기본순으로 정렬합니다.");
                        applySortOnly();
                        return;
                    }
                    updatePlacesDistances(processedPlaces);
                    processedPlaces.sort((a, b) => (a.distance ?? Infinity) - (b.distance ?? Infinity));
                    displayPlaces(processedPlaces);
                });
            } else {
                if (sort === 'name') {
                    processedPlaces.sort((a, b) => a.place_name.localeCompare(b.place_name));
                }
                updatePlacesDistances(processedPlaces, () => displayPlaces(processedPlaces));
            }
        }

        function getUserLocation(callback, forceRefresh = false) {
            // 강제 새로고침이 아니고, 기존 위치 정보가 있을 때만 캐시를 사용
            if (userLocation && !forceRefresh) {
                return callback();
            }

            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {

                    // ================================================================
                    // ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼ 디버깅 코드 추가 ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
                    console.log("브라우저가 전달한 위치 정보:", position);
                    alert(`새로 받은 좌표:\n위도: ${position.coords.latitude}\n경도: ${position.coords.longitude}`);
                    // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲ 디버깅 코드 추가 ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
                    // ================================================================

                    userLocation = { lat: position.coords.latitude, lng: position.coords.longitude };
                    if (callback) callback();
                }, error => {
                    if (callback) callback(true);
                }, { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 });
            } else {
                if (callback) callback(true);
            }
        }

        function displayMyLocation() {
            // '내 위치 보기' 기능은 다른 기능과 독립적으로, 항상 새로 위치를 가져옵니다.
            if (navigator.geolocation) {
                // 옵션을 통해 브라우저 캐시를 사용하지 않도록 명시합니다.
                const geoOptions = {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: 0
                };

                navigator.geolocation.getCurrentPosition(position => {
                    // 1. 새로 가져온 정확한 위치를 전역 변수에 즉시 업데이트합니다.
                    //    이렇게 해야 목록의 거리 표시도 이 최신 위치를 기준으로 다시 계산됩니다.
                    userLocation = { lat: position.coords.latitude, lng: position.coords.longitude };

                    // 2. 지도에 '내 위치' 마커와 원을 새로 그립니다.
                    const locPosition = new kakao.maps.LatLng(userLocation.lat, userLocation.lng);
                    if (myLocationMarker) myLocationMarker.setMap(null);
                    if (myLocationCircle) myLocationCircle.setMap(null);

                    myLocationMarker = new kakao.maps.Marker({
                        map: map,
                        position: locPosition,
                        image: new kakao.maps.MarkerImage('https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/markerStar.png', new kakao.maps.Size(24, 35), {offset: new kakao.maps.Point(12, 35)})
                    });
                    myLocationCircle = new kakao.maps.Circle({
                        map: map,
                        center: locPosition,
                        radius: currentSearchRadius,
                        strokeWeight: 2,
                        strokeColor: '#004CFF',
                        strokeOpacity: 0.8,
                        strokeStyle: 'dashed',
                        fillColor: '#CCE7FF',
                        fillOpacity: 0.5
                    });
                    map.setCenter(locPosition);
                    map.setLevel(calculateLevelForRadius(currentSearchRadius));

                    // 3. 현재 표시된 장소 목록의 거리를 새로고침된 위치 기준으로 다시 계산하고,
                    //    화면을 업데이트하여 즉시 반영합니다.
                    updatePlacesDistances(originalPlaces, () => {
                        // 만약 현재 '거리순'으로 정렬된 상태였다면, 목록 순서도 다시 정렬합니다.
                        if (document.getElementById('sort').value === 'distance') {
                            originalPlaces.sort((a, b) => (a.distance ?? Infinity) - (b.distance ?? Infinity));
                        }
                        displayPlaces(originalPlaces);
                    });

                }, () => {
                    alert('오류: 위치 정보를 가져오는 데 실패했습니다.');
                }, geoOptions);
            } else {
                alert('오류: 이 브라우저에서는 위치 정보 기능을 사용할 수 없습니다.');
            }
        }

        function changeSearchRadius() {
            currentSearchRadius = parseInt(document.getElementById('radiusSelect').value);
            if (myLocationCircle) myLocationCircle.setRadius(currentSearchRadius);
        }

        function calculateLevelForRadius(radius) {
            if (radius <= 500) return 4; if (radius <= 1000) return 5;
            if (radius <= 2000) return 6; if (radius <= 5000) return 7;
            return 8;
        }

        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const dLat = (lat2-lat1) * Math.PI/180; const dLon = (lon2-lon1) * Math.PI/180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) * Math.sin(dLon/2) * Math.sin(dLon/2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        function updatePlacesDistances(places, callback) {
            if (!userLocation || !places) {
                if (callback) callback();
                return;
            }
            places.forEach(place => {
                const lat = parseFloat(place.y); const lng = parseFloat(place.x);
                if (!isNaN(lat) && !isNaN(lng)) {
                    place.distance = getDistance(userLocation.lat, userLocation.lng, lat, lng);
                } else { place.distance = null; }
            });
            if (callback) callback();
        }

        function displayPlaces(places) {
            const listEl = document.getElementById('placesList');
            removeAllChildNods(listEl);
            removeMarker();
            if (!places || places.length === 0) {
                listEl.innerHTML = '<li class="text-gray-500">선택한 조건에 맞는 결과가 없습니다.</li>';
                return;
            }
            places.forEach((place, i) => {
                if (typeof place.y === 'string' && typeof place.x === 'string' && !isNaN(parseFloat(place.y)) && !isNaN(parseFloat(place.x))) {
                    const placePosition = new kakao.maps.LatLng(parseFloat(place.y), parseFloat(place.x));
                    const marker = addMarker(placePosition, i, place.id, place.place_name);
                    const itemEl = getListItem(i, place);
                    listEl.appendChild(itemEl);
                    itemEl.onmouseover = () => {
                        const targetMarker = markers.find(m => m.placeId === place.id);
                        if (targetMarker && currentActiveMarker !== targetMarker) {
                            targetMarker.setImage(targetMarker.hoverImage);
                            infowindow.setContent(`<div class="info"><div class="title">${place.place_name}</div></div>`);
                            infowindow.open(map, targetMarker);
                        }
                    };
                    itemEl.onmouseout = () => {
                        const targetMarker = markers.find(m => m.placeId === place.id);
                        if (targetMarker && currentActiveMarker !== targetMarker) {
                            targetMarker.setImage(targetMarker.normalImage);
                            infowindow.close();
                        }
                    };
                    itemEl.onclick = (event) => {
                        if (event.target.tagName === 'BUTTON' || event.target.closest('a')) return;
                        const targetMarker = markers.find(m => m.placeId === place.id);
                        if (targetMarker) {
                            if (currentActiveMarker && currentActiveMarker !== targetMarker) currentActiveMarker.setImage(currentActiveMarker.normalImage);
                            targetMarker.setImage(targetMarker.hoverImage);
                            currentActiveMarker = targetMarker;
                            map.panTo(targetMarker.getPosition());
                            infowindow.setContent(`<div class="info"><div class="title">${place.place_name}</div></div>`);
                            infowindow.open(map, targetMarker);
                            highlightListItem(place.id);
                        }
                    };
                }
            });
        }

        function addMarker(position, idx, placeId, placeName) {
            const normalImageSrc = 'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/marker_number_blue.png', imageSize = new kakao.maps.Size(36, 37);
            const normalImgOptions = { spriteSize: new kakao.maps.Size(36, 691), spriteOrigin: new kakao.maps.Point(0, (idx * 46) + 10), offset: new kakao.maps.Point(13, 37) };
            const markerImageNormal = new kakao.maps.MarkerImage(normalImageSrc, imageSize, normalImgOptions);
            const hoverImageSrc = 'http://t1.daumcdn.net/localimg/localimages/07/mapapidoc/marker_red.png', hoverImageSize = new kakao.maps.Size(31, 35);
            const hoverImgOptions = { offset: new kakao.maps.Point(13, 34) };
            const markerImageHover = new kakao.maps.MarkerImage(hoverImageSrc, hoverImageSize, hoverImgOptions);
            const marker = new kakao.maps.Marker({ position: position, image: markerImageNormal });
            marker.normalImage = markerImageNormal; marker.hoverImage = markerImageHover;
            marker.placeId = placeId; marker.placeName = placeName;
            marker.setMap(map); markers.push(marker); return marker;
        }

        function removeMarker() {
            markers.forEach(m => m.setMap(null)); markers = [];
            currentActiveMarker = null; infowindow.close();
        }

        function highlightListItem(placeId) {
            document.querySelectorAll('#placesList .highlighted').forEach(el => el.classList.remove('highlighted'));
            const itemEl = document.querySelector(`#placesList div[data-place-id="${placeId}"]`);
            if (itemEl) {
                itemEl.classList.add('highlighted');
                itemEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        function getListItem(index, place) {
            const el = document.createElement('li');
            const distanceInfo = place.distance ? `<span class="text-sm font-semibold ${place.distance * 1000 <= currentSearchRadius ? 'text-red-500' : 'text-blue-500'}">거리: ${place.distance.toFixed(2)}km</span>` : '';
            el.innerHTML = `<div class="p-3 border rounded-lg hover:bg-gray-100 cursor-pointer" data-place-id="${place.id}">
                                <div class="flex justify-between items-start">
                                    <div><h5 class="font-bold text-blue-600">${index + 1}. ${place.place_name}</h5></div>
                                    <div class="flex flex-col items-end gap-2">${distanceInfo}<button onclick="savePlace(event, ${index})" class="bg-green-500 text-white text-xs px-2 py-1 rounded hover:bg-green-600">저장</button></div>
                                </div>
                                ${place.road_address_name ? `<span class="text-sm text-gray-700">${place.road_address_name}</span><span class="text-xs text-gray-500 block">${place.address_name}</span>` : `<span class="text-sm text-gray-700">${place.address_name}</span>`}
                                <span class="text-sm text-green-600">${place.phone}</span>
                            </div>`;
            return el;
        }

        async function savePlace(event, index) {
            event.stopPropagation();
            const place = originalPlaces[index];
            const placeData = {
                name: place.place_name, address: place.road_address_name || place.address_name,
                phoneNumber: place.phone, category: place.category_name,
                latitude: parseFloat(place.y), longitude: parseFloat(place.x),
                rating: null, priceLevel: null, operatingHours: null
            };
            if (placeData.category && placeData.category.includes('>')) {
                placeData.category = placeData.category.split('>').pop().trim();
            } else if (placeData.category === '맛집') {
                placeData.category = '기타';
            }
            try {
                const response = await fetch('/api/lunchmatches', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(placeData),
                });
                if (response.status === 201) alert(`'${place.place_name}' 맛집이 저장되었습니다.`);
                else if (response.status === 409) alert(await response.text());
                else throw new Error(`서버 오류: ${response.status}`);
            } catch (error) {
                console.error('맛집 저장 중 오류 발생:', error);
                alert('맛집을 저장하는 중 오류가 발생했습니다.');
            }
        }

        function removeAllChildNods(el) { while (el.hasChildNodes()) el.removeChild(el.lastChild); }

        // ▼▼▼ 전체 지도 보기 JavaScript 함수 추가 ▼▼▼
        function openFullScreenMap() {
            const modal = document.getElementById('fullscreen-map-modal');
            modal.classList.remove('opacity-0', 'pointer-events-none');
            const mapContainer = document.getElementById('fullscreen-map');
            if (!modalMap) {
                modalMap = new kakao.maps.Map(mapContainer, {
                    center: map.getCenter(),
                    level: map.getLevel()
                });
            }
            setTimeout(() => {
                modalMap.relayout();
                modalMap.setCenter(map.getCenter());
                modalMap.setLevel(map.getLevel());
                markers.forEach(marker => {
                    new kakao.maps.Marker({
                        map: modalMap, position: marker.getPosition(),
                        image: marker.getImage()
                    });
                });
                if (myLocationMarker) {
                    new kakao.maps.Marker({
                        map: modalMap, position: myLocationMarker.getPosition(),
                        image: myLocationMarker.getImage()
                    });
                }
            }, 100);
        }

        function closeFullScreenMap() {
            const modal = document.getElementById('fullscreen-map-modal');
            modal.classList.add('opacity-0', 'pointer-events-none');

            document.getElementById('fullscreen-map').innerHTML = '';
            modalMap = null;

            if (modalMyLocationMarker) {
                modalMyLocationMarker.setMap(null);
                modalMyLocationMarker = null;
            }
            // [추가] 모달의 원도 함께 제거합니다.
            if (modalMyLocationCircle) {
                modalMyLocationCircle.setMap(null);
                modalMyLocationCircle = null;
            }
        }
        function displayMyLocationOnModal() {
            if (!modalMap) return;

            if (navigator.geolocation) {
                const geoOptions = { /* ... */ };

                navigator.geolocation.getCurrentPosition(position => {
                    const locPosition = new kakao.maps.LatLng(position.coords.latitude, position.coords.longitude);

                    // 기존 마커 제거
                    if (modalMyLocationMarker) {
                        modalMyLocationMarker.setMap(null);
                    }
                    // [추가] 기존 원 제거
                    if (modalMyLocationCircle) {
                        modalMyLocationCircle.setMap(null);
                    }

                    // 새로운 마커 생성
                    modalMyLocationMarker = new kakao.maps.Marker({
                        map: modalMap,
                        position: locPosition,
                        image: new kakao.maps.MarkerImage('https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/markerStar.png', new kakao.maps.Size(24, 35), {offset: new kakao.maps.Point(12, 35)})
                    });

                    // [추가] 새로운 원 생성
                    modalMyLocationCircle = new kakao.maps.Circle({
                        map: modalMap,
                        center: locPosition,
                        radius: currentSearchRadius,
                        strokeWeight: 2,
                        strokeColor: '#004CFF',
                        strokeOpacity: 0.8,
                        strokeStyle: 'dashed',
                        fillColor: '#CCE7FF',
                        fillOpacity: 0.5
                    });

                    modalMap.setCenter(locPosition);
                }, () => { /* ... */ }, geoOptions);
            } else { /* ... */ }
        }


    </script>
</th:block>
</html>