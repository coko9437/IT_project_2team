1. 시작 시 Security 필터 체인 작동:

스프링 시큐리티가 설정되어 있다면, 애플리케이션에 처음 접속하거나 보호된 리소스에 접근하려고 할 때 가장 먼저 스프링 시큐리티의 필터 체인이 작동합니다.

만약 현재 사용자가 인증되지 않은 상태이고, 접근하려는 페이지가 인증을 요구하는 페이지라면, 스프링 시큐리티 설정에 따라 자동으로 로그인 페이지로 리다이렉트될 것입니다.

회원가입 페이지(api/members/signup 엔드포인트)는 일반적으로 인증 없이 접근할 수 있도록 시큐리티 설정에서 permitAll() 등으로 허용되어야 합니다. 그렇지 않으면 회원가입조차 할 수 없게 됩니다.

2. 회원가입 요청 처리 (MemberController):

클라이언트(웹 브라우저의 HTML 폼 또는 Postman/cURL 등)에서 /api/members/signup 경로로 POST 요청을 보냅니다. 이때 consumes = MediaType.MULTIPART_FORM_DATA_VALUE 설정에 따라 multipart/form-data 형식으로 데이터를 전송해야 합니다.

요청 본문에는 memberSignupDTO (회원 정보 JSON 데이터)와 profileImage (선택적 프로필 이미지 파일)가 포함됩니다.

@RequestPart("memberSignupDTO") MemberSignupDTO memberSignupDTO 어노테이션 덕분에 JSON 데이터가 MemberSignupDTO 객체로 자동 변환됩니다.

@Valid 어노테이션에 의해 MemberSignupDTO에 정의된 @NotBlank, @NotNull, @Email, @Pattern 등의 유효성 검사가 자동으로 수행됩니다. (예: 비밀번호가 비어있거나, 이메일 형식이 잘못되었거나, 생년월일이 null인 경우 등)

컨트롤러 내부에서 비밀번호와 비밀번호 확인(confirmPassword)이 일치하는지 1차적으로 검사합니다.

프로필 이미지가 있다면 ProfileDTO를 생성하여 MultipartFile을 담습니다.

memberService.registerMember 메서드를 호출하여 회원가입 비즈니스 로직을 위임합니다.

성공 시 ResponseEntity.ok()로 성공 메시지와 memberId를 JSON 형태로 반환합니다.

IllegalArgumentException (예: 중복 아이디, 비밀번호 불일치 등) 발생 시 ResponseEntity.badRequest()로 오류 메시지를 반환합니다.

그 외 RuntimeException (예: 파일 업로드 실패, DB 저장 오류 등) 발생 시 ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)로 서버 오류 메시지를 반환합니다.

3. 회원가입 비즈니스 로직 처리 (MemberServiceImpl):

registerMember 메서드가 호출되면, 먼저 MemberSignupDTO의 유효성 검사(중복 아이디, 이메일, 전화번호, 닉네임)를 수행합니다.

ModelMapper를 사용하여 MemberSignupDTO 객체를 Member 엔티티 객체로 변환합니다. 이때 Member 엔티티에 @Setter가 추가되어 birthDate를 포함한 DTO의 필드 값들이 엔티티로 올바르게 매핑됩니다.

사용자가 입력한 비밀번호는 PasswordEncoder를 통해 암호화되어 Member 엔티티의 password 필드에 저장됩니다.

닉네임 중복 시 고유한 닉네임을 생성하는 로직(generateUniqueNickname)이 적용됩니다.

Member 엔티티에 MemberRole.USER 역할을 부여합니다.

프로필 이미지가 있다면, 서버의 특정 경로(uploadPath 설정)에 파일을 저장하고, 썸네일을 생성하며, 파일의 UUID, 원본 파일명, 저장 경로, 이미지 여부 등 관련 정보를 Member 엔티티에 업데이트합니다.

최종적으로 memberRepository.save(member)를 호출하여 Member 엔티티를 데이터베이스(member_tbl)에 저장합니다.

저장 과정에서 DataIntegrityViolationException (데이터베이스 제약 조건 위반, 예: NOT NULL 필드에 null 삽입) 같은 예외가 발생하면 이를 처리하고 RuntimeException을 발생시킵니다.

성공적으로 저장되면 저장된 Member의 id를 반환합니다.

4. 데이터베이스 저장:

MemberRepository는 Spring Data JPA를 사용하여 Member 엔티티를 데이터베이스(member_tbl)에 영속화(저장)합니다.

id, username, password, phoneNumber, birthDate, email, nickname, regDate, modDate, profileImageUuid, profileImageName, profileImagePath, hasProfileImage 등의 정보가 member_tbl에 저장됩니다.

roles 정보는 member_roles라는 별도의 테이블에 member_id와 role_name으로 저장됩니다 (@ElementCollection).


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ이메일 인증ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
1 회원가입 폼에 이메일 인증 관련 UI 추가:

이메일 입력 필드 옆에 "인증번호 받기" 버튼을 추가합니다.

인증번호 입력 필드를 추가합니다.

인증번호 입력 필드 옆에 "인증 확인" 버튼을 추가합니다.

인증 성공/실패 메시지를 표시할 영역을 추가합니다.

인증이 완료되었는지 여부를 사용자에게 시각적으로 보여줄 상태 표시(예: "인증 완료" 텍스트, 체크 표시 등)를 추가합니다.



2 JavaScript로 이메일 인증 로직 구현:

"인증번호 받기" 버튼 클릭 시:

이메일 입력 필드의 값을 가져옵니다.

/api/auth/send-code 엔드포인트로 POST 요청을 보냅니다 (이메일 주소 포함).

성공 응답을 받으면 "인증번호가 전송되었습니다." 메시지를 표시하고, 인증번호 입력 필드를 활성화합니다.

실패 응답을 받으면 에러 메시지를 표시합니다.

(선택 사항) 인증번호 재전송 방지를 위해 일정 시간 동안 버튼을 비활성화합니다.

"인증 확인" 버튼 클릭 시:

이메일 입력 필드의 값과 인증번호 입력 필드의 값을 가져옵니다.

/api/auth/verify-code 엔드포인트로 POST 요청을 보냅니다 (이메일 주소와 인증번호 포함).

성공 응답을 받으면 "이메일 인증이 완료되었습니다." 메시지를 표시하고, 이메일 입력 필드와 인증번호 관련 버튼/필드를 비활성화하여 더 이상 수정할 수 없게 만듭니다. 또한, 회원가입 폼의 나머지 필드들(아이디, 비밀번호 등)을 활성화하거나, isEmailVerified와 같은 숨겨진 필드에 상태를 저장합니다.

실패 응답을 받으면 "인증번호가 일치하지 않거나 만료되었습니다." 같은 에러 메시지를 표시합니다.



3 회원가입 버튼 활성화 조건:

가장 중요한 부분: 이메일 인증이 성공적으로 완료되기 전까지는 "회원가입" 버튼을 비활성화(disabled) 상태로 유지합니다.

이메일 인증 성공 시에만 "회원가입" 버튼을 활성화시켜 사용자가 회원가입 요청을 보낼 수 있도록 합니다.

##

1. 이메일 인증 성공 시 MemberRepository로 DB에 들어가고, 이메일 인증은 DB에 넣을 필요 없는지?
이메일 인증 성공 시 MemberRepository로 DB에 들어가는 것:

네, 회원가입 요청이 성공적으로 완료되면 Member 엔티티가 MemberRepository를 통해 DB에 저장됩니다. 이메일 인증은 회원가입을 위한 선행 조건이 됩니다.

이메일 인증 API(verify-code) 자체는 DB에 직접적으로 데이터를 저장하지 않습니다. 단지 메모리(authStorage)에 임시로 저장된 인증 정보를 확인하고 삭제할 뿐입니다.

이메일 인증 정보 자체를 DB에 넣을 필요 없는지?

일반적으로 이메일 인증 코드(authCode) 자체는 DB에 영구적으로 저장할 필요가 없습니다. 왜냐하면 인증 코드는 일회용이며, 유효 기간이 짧기 때문입니다 (현재 5분). 인증이 완료되면 바로 폐기되는 정보입니다.

\\\\\\\\\\\\\\\\\
다만, Member 엔티티에 "이메일 인증 완료 여부"를 나타내는 필드를 추가하는 것은 매우 권장됩니다.

예를 들어 Member 엔티티에 private boolean isEmailVerified; 필드를 추가하고, 이메일 인증이 성공하면 이 값을 true로 설정하여 DB에 저장하는 것입니다.

이렇게 하면 나중에 사용자가 로그인했을 때 isEmailVerified 값을 확인하여 이메일 인증이 완료된 계정인지 아닌지 구분할 수 있습니다. 예를 들어, 이메일 인증이 안 된 계정은 특정 기능 사용에 제한을 두거나, 인증을 독려하는 메시지를 보여줄 수 있습니다.

##전체흐름
1 사용자가 이메일 인증 요청.

2 인증 코드 전송 및 입력.

3 인증 코드 확인 (프론트엔드에서 /api/auth/verify-code 호출).

4 백엔드 (MemberServiceImpl)에서 회원가입 처리 시, MemberSignupDTO에 "이메일이 인증되었음"을 나타내는 플래그 또는 인증에 사용된 이메일 주소를 받아 EmailAuthService.verifyAuthCode(email, authCode)를 다시 호출하여 최종적으로 인증 여부를 검증합니다. (이게 가장 안전한 방법)

5 이메일 인증이 성공한 경우에만 Member 엔티티를 저장하고, 이때 isEmailVerified 필드를 true로 설정하여 저장합니다.

6 인증에 성공하지 못하면 회원가입이 실패하도록 MemberServiceImpl에서 IllegalArgumentException을 발생


########최종로직
최종 회원가입 로직 순서 (이메일 인증 통합)
-- 프론트엔드 (사용자 웹 브라우저)

1 회원가입 페이지 접속: 사용자가 웹 브라우저를 통해 회원가입 페이지(signup.html)에 접속합니다. 스프링 시	큐리티 설정에 따라 인증 없이 접근 가능해야 합니다.

2 이메일 입력 및 인증 요청:
	사용자가 이메일 주소를 입력하고 "인증번호 받기" 버튼을 클릭합니다.
	JavaScript가 /api/auth/send-code API를 호출하여 백엔드에 이메일 전송을 요청합니다.

3 인증번호 수신 및 입력:
	백엔드로부터 "인증번호가 전송되었습니다." 응답을 받으면, 사용자는 메일함에서 인증번호를 확인하고 	"인증번호" 입력 필드에 해당 번호를 입력합니다.

	(선택) 이때, 나머지 회원가입 필드(아이디, 비밀번호 등)는 아직 비활성화 상태입니다.

4 인증번호 확인 요청:
	사용자가 인증번호를 입력한 후 "인증 확인" 버튼을 클릭합니다.

	JavaScript가 /api/auth/verify-code API를 호출하여 백엔드에 이메일 주소와 인증번호를 보내 확인을 요	청합니다.

5 이메일 인증 성공:
	백엔드로부터 "인증 성공" 응답을 받으면, 프론트엔드에서는 "이메일 인증이 완료되었습니다." 메시지를 	표시하고 이메일 및 인증번호 관련 필드들을 비활성화하여 더 이상 수정할 수 없게 만듭니다.
	동시에, 나머지 회원가입 필드(아이디, 비밀번호, 닉네임, 생년월일, 전화번호)와 "회원가입" 버튼을 활성	화합니다.
	(선택) 인증 실패 시에는 "인증번호 불일치/만료" 메시지를 표시하고, 재시도를 유도합니다.

6 회원 정보 입력: 활성화된 필드에 아이디, 비밀번호, 닉네임, 생년월일, 전화번호, 그리고 선택적으로 프로필 사	진을 입력합니다. (프로필 사진 선택 시 썸네일 미리보기)

7 회원가입 요청:
	사용자가 모든 정보를 입력한 후 "회원가입" 버튼을 클릭합니다.
	JavaScript는 폼 데이터를 FormData 객체로 생성하고, 이 안에 memberSignupDTO (JSON 형태의 회원 	정보 및 이메일, 이메일 인증 코드 포함)와 profileImage 파일을 담아 /api/members/signup API로 POST 	요청을 보냅니다.

-- 백엔드 (Spring Boot 애플리케이션)

8 회원가입 요청 수신 (MemberController):
	/api/members/signup 엔드포인트로 POST 요청이 들어오면 MemberController의 signupMember 메서	드가 이를 받습니다.
	@RequestPart를 통해 MemberSignupDTO와 ProfileDTO (파일)를 파싱하고 @Valid를 통해 DTO의 기본	적인 유효성 검사를 수행합니다.
	memberService.registerMember 메서드를 호출하며 회원가입 비즈니스 로직을 위임합니다.

9 회원가입 비즈니스 로직 처리 (MemberServiceImpl):
	registerMember 메서드가 실행됩니다.
	기본 유효성 검사: 비밀번호 일치 여부, 아이디/이메일/전화번호/닉네임 중복 여부를 1차적으로 확인합니	다.

9-1 이메일 인증 최종 검증:
	EmailAuthService.verifyAuthCode(memberSignupDTO.getEmail(), 	memberSignupDTO.getEmailAuthCode())를 호출하여 서버에서 최종적으로 이메일 인증 코드가 유효한	지 확인합니다.

	만약 이 검증에 실패하면, IllegalArgumentException을 발생시켜 회원가입을 중단하고 실패 응답을 보냅	니다.

9-2 데이터 변환 및 가공:
	ModelMapper를 이용해 MemberSignupDTO를 Member 엔티티로 변환합니다.
	passwordEncoder를 이용해 비밀번호를 암호화합니다.
	닉네임 중복 시 고유한 닉네임을 생성합니다.
	Member 엔티티에 MemberRole.USER 역할을 부여합니다.

	중요: 이메일 인증이 성공했으므로, member.setEmailVerified(true)로 엔티티의 이메일 인증 상태를 true	로 설정합니다.

9-3 프로필 사진 처리 (선택 사항):
	ProfileDTO에 파일이 있다면, 서버에 저장 경로를 만들고 파일을 저장합니다.
	이미지 파일일 경우 썸네일을 생성합니다.
	파일 저장 정보를 Member 엔티티에 업데이트합니다 (profileImageUuid, profileImageName,	profileImagePath, hasProfileImage).

10 데이터베이스 저장:
	memberRepository.save(member)를 호출하여 모든 회원 정보를 member_tbl 테이블에 저장합니다. 이	때 isEmailVerified 컬럼 값은 true로 저장됩니다.
	저장 중 발생할 수 있는 데이터베이스 관련 예외(DataIntegrityViolationException 등)를 처리합니다.

11 응답 반환 (MemberController):
	회원가입 비즈니스 로직이 성공하면 MemberController로 성공 응답이 돌아옵니다.
	MemberController는 성공 메시지(회원 ID 포함)와 HTTP 200 OK 상태를 클라이언트(프론트엔드)로 반환	합니다.
	실패 시에는 적절한 오류 메시지와 HTTP 400 Bad Request 또는 500 Internal Server Error 상태를 반환	합니다.

-- 프론트엔드 (다시 사용자 웹 브라우저)

12 회원가입 결과 처리:
	클라이언트의 JavaScript가 백엔드로부터 받은 응답을 처리합니다.
	성공 시: "회원가입이 성공적으로 완료되었습니다." 모달을 띄우고, 사용자가 확인 버튼을 누르면 /login 	페이지(또는 지정된 메인 페이지)로 리다이렉트합니다.
	
	실패 시: "회원가입 실패" 모달을 띄우고 백엔드에서 받은 상세 오류 메시지를 표시합니다. 사용자가 확인 	버튼을 눌러도 페이지를 벗어나지 않고, 폼을 수정하여 다시 시도할 수 있도록 합니다.